ClassScheduler-GitHub

## Problem Characterization

The goal of this implementation is to create a middle school class scheduler, such as the one below. As it can be seen, we have the schedule of each of the four class groups (6th to 9th), and each of them with two cohorts - thus, a total of 8 cohorts of students. Their schedule has six classes a day (referred to as slots), from Monday to Friday. At the beginning of the semester, it takes a lot of administrative mental effort to organize the schedule. Thus, the purpose of this algorithm is to create this schedule for the school, within the constraints that all cohorts need to have all six classes every day and that we cannot hire more Professors. This can be defined as a constraint satisfaction problem as we must find a schedule within given constraints (e.g., all classes must have all classes everyday, teachers must have their total amount of classes fulfilled, and they can only come to school on specified days).

This project is often solved using backtracking (which means a brute force way in which we test solutions, and change it if eventually we find out that there is a mistake), so the goal is to propose an optimized approach. Unfortunately, upon a bit of research I realized that this scheduling problem might be the so-called “NP problem” (nondeterministic polynomial time) - one of those problems in which it is easier to figure whether a solution is fittable rather than finding the solution itself (other examples of that would be a sudoku puzzle, or the Knapsack problem, previously described).


### Dynamic Programming?

It is interesting to see the similarities between the Course Scheduling problem with other dynamic programming problems. As the 0-1 Knapsack problem, the goal of the scheduling problem is to find the best combination of courses for each teacher (for each of the cohorts). Nonetheless, the key difference is that the Course Scheduling problem is interested in the order of the combination, whereas it made no difference in the Knapsack problem if we had item 1 first and 2 second or vice-versa. On the other hand, in the longest common subsequence problem, we were interested in the order of the combination (e.g., “ABCD” and “BCD” will have a different longest common subsequence compared to “CABD” and “BCD”), but the Course Scheduling has the combinatorics component that the latter does not.

Another key difference between the Course Scheduler problem, the Knapsack problem and the Longest Common Subsequence is that the first is not directly optimizing a specific metric, such as we had in the two latter (in which we maximized the amount of dollars we would yield under the weight constraint in the former, and the longest possible common subsequence of strings in the latter). For the Course Scheduler problem, there is no maximization goal, as it is enough to simply find one solution that fits all the constraints. In this case, we can create a metric to compare two potential schedulers (as it will be previously described). Nonetheless, the challenge would be satisfying the given constraint, before comparing potential solutions.

The consequence of the lack of a direct optimizations strategy in this problem is one of the reasons why the implementation of a dynamic programming strategy to solve it is complicated. As we know, dynamic programming requires finding the solution to a subproblem, and from there building an optimized solution to the problem (as long as the problem fulfills the optimal substructure and the overlapping problems conditions). Because we are not optimizing for a given metric in the standard problem, we have no way of realizing whether there is a difference
between choosing Professor A for time slot 1 and Professor B for time slot 2, or vice versa. Because we do not have a way to differentiate them, it is questionable whether the Course Scheduler problem fulfills the optimal substructure requirement - which is required for both dynamic programming approaches and greedy algorithms. The optimal substructure requirement says that we can use the optimal solution at the local level to build the global optimum. Nonetheless, without a metric, we can not figure out what is the best local level solution. Thus, it is necessary to introduce a measure of metric to be able to optimize a solution.

### Metric: Availability Score

The metric I will create for this solution is inspired by the solution to the fractional Knapsack problem. We know that the most optimal solution at the local level for that problem was to get the largest rate between value and weight at any step. Thus, we will find a useful rate that can help us in our decision making.

We will look at the problem from the perspective of having to choose between multiple teachers to teach a given day of the week for a given cohort. We assume the day of the week and the cohort as given. Thus, we must first look at the teachers who (1) are available to teach on that day; and (2) are assigned to teach that given cohort. Thus, we can think of an availability score .

The availability score A for professor p , day d and cohort c is the ratio between classes that have yet to be scheduled (at the time of assignment) and the amount of days the teachers are available at the school.4 The idea is that, in order to pick which classes a given cohort will have on a given day, we will prioritize scheduling less available teachers first (i.e., teachers with the highest availability score - as they have more classes and less days), as they are more likely to be unavailable. This availability score has to be updated every time the teacher is scheduled for a given class slot, as this changes how available it is for upcoming schedules.

It is also important to acknowledge that the days available metric also changes in the upcoming algorithm. Because I am implementing the schedules in a day by day casis, it is necessary that the availability score takes into account teachers who have more classes to schedule, but only a few more days available, because the scheduler is currently booking Wednesday. It becomes more clear if we think about an example. Let’s imagine Teacher Ribeiro is available Monday, Wednesday and Friday and that she is teaching 5 classes. Thus, the initial availability score is 5/3. The algorithm will start by scheduling Monday and, because the availability score is not that high compared to other teachers, she is not scheduled. After scheduling all the classes from Monday and Tuesday, we start computing the Wednesday schedule. Now, we can no longer use the availability score of 5/3, as it would still be small and there is a chance Teacher Ribeiro will not be scheduled again. Hence, we must take into account that she only has two more days to be scheduled. Thus, her new availability score will be 5/2, which might result in her being scheduled for Wednesday.

There are still a couple follow-up questions to be answered.

#### How to decide which cohort to assign teachers first?

It is important to acknowledge that the cohort that gets to compare its teachers availability scores first might have more options of teachers to choose from (as they might become unavailable after other cohorts get them in their schedules). Thus, it is important to optimize which classes might get teachers assigned first.

To decide what is the first cohort to be assigned teachers for a given day, we can calculate the sum of the availability scores of all the teachers who are available for a given day and have classes to be taught for that given cohort (accounting for all classes yet to be scheduled - thus, if the teacher have classes with all cohorts, the numerator will be the same at this stage). The higher the sum of the availability scores, the more unavailable are the teachers (they have more classes to be scheduled, and less days to teach). Hence, the classes with higher sum of availability scores will be assigned teachers first, in descending order.

##### After having picked the six teachers that will teach on a given day, how to define the most optimal order of their schedules?

That is a key step in whether the algorithm is working or not. Even if we pick the right teachers at any given day, scheduling them in the wrong order might make the whole schedule not to work.
 
Unfortunately, the current implementation does not take that into account. The way it organizes the order of the teachers is simply by assigning the teacher with the highest availability score at any given moment to the next slot (moving from the beginning of the day to the end). Although this decision was mostly thinking on easing the implementation, it makes some sense that the algorithm will prioritize the teachers’ highest availability score, because they have more classes to teach and less days availability. Nonetheless, it has drawbacks, which will be discussed in the upcoming section.

##### What if it does not work? Does this metric make dynamic programming approaches and greedy strategies possible?

Still, there is nothing about the constraint satisfied. There is nothing about this metric that guarantees that all the teachers will have their classes scheduled in days they are available. Although we can include some extra constraints to prevent this from happening in the algorithm, it does not guarantee that all teachers will be fit in the schedule (despite having a potential solution to it), as can be seen in the Implementation Section below. Thus, this means that the availability score might not fit some of the property of greedy algorithms and dynamic programming approaches. First, it is important to acknowledge that this metric can only be used to tell us which teacher is the most available, but it does not guarantee that we are choosing the best slot to fit a given teacher (as explained in the previous question). Thus, this does not satisfy the optimal substructure, as there is no way we can know that a given set up (of teacher and time slot) will be more fit than another). Because this is a required feature to obtain an optimal solution in both algorithms, we know that the upcoming implementation might not yield the optimal solution by itself.

There are other unaddressed features as well. The greedy-choice property (which states that the local solution is the most optimal one) also does not hold, for the same reason: we do not know where is the most optimal slot to put a given teacher. Lastly, we have to consider the overlapping subproblems feature of dynamic programming, which also does not hold, as, by not knowing what is the most optimal solution, we cannot use it at the local level and memoize it to build a global optimum solution later on.

Because of these many constraints, I chose not to implement a dynamic programming solution to this problem. Because both of its properties do not hold, there is no reason to believe that a dynamic programming strategy would be useful to solve it. It would be like cutting a piece of a key to try to fit it in a lock. As it will be seen in the Implementation section that follows, I used features of a greedy solution to solve the problem. Nonetheless, as mentioned, it does not guarantee that solution will yield an optimal solution. We might have to rely on the human capacity and/or some form of backtracking to reach a possible solution.